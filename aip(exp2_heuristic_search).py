# -*- coding: utf-8 -*-
"""AIP(exp2-Informed Search).ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1jY8qotj6leiTuT4KF9a-7XcYttuCEExa
"""

import queue

def getHeuristics():
  heuristics = {}
  f = open("heuristics.txt")
  for i in f.readlines():
    node_heuristic_val = i.split()
    heuristics[node_heuristic_val[0]] = int(node_heuristic_val[1])
  return heuristics

def createGraph():
  graph = {}
  file = open("citiesGraph.txt")
  for i in file.readlines():
    node_val = i.split()
    if node_val[0] in graph and node_val[1] in graph:
      c = graph.get(node_val[0])
      c.append([node_val[1], node_val[2]])
      graph.update({node_val[0]: c})
      c = graph.get(node_val[1])
      c.append([node_val[0], node_val[2]])
      graph.update({node_val[1]: c})

    elif node_val[0] in graph:
      c = graph.get(node_val[0])
      c.append([node_val[1], node_val[2]])
      graph.update({node_val[0]: c})
      graph[node_val[1]] = [[node_val[0], node_val[2]]]

    elif node_val[1] in graph:
      c = graph.get(node_val[1])
      c.append([node_val[0], node_val[2]])
      graph.update({node_val[1]: c})
      graph[node_val[0]] = [[node_val[1], node_val[2]]]

    else:
      graph[node_val[0]] = [[node_val[1], node_val[2]]]
      graph[node_val[1]] = [[node_val[0], node_val[2]]]
  return graph

def GBFS(startNode, heuristics, graph, goalNode="Bucharest"):
  priorityQueue = queue.PriorityQueue()
  priorityQueue.put((heuristics[startNode], startNode))
  path = []
  while priorityQueue.empty() == False:
    current = priorityQueue.get()[1]
    path.append(current)
    if current == goalNode:
      break
    priorityQueue = queue.PriorityQueue()
    for i in graph[current]:
      if i[0] not in path:
        priorityQueue.put((heuristics[i[0]], i[0]))
  return path

def Astar(startNode, heuristics, graph, goalNode="Bucharest"):
  priorityQueue = queue.PriorityQueue()
  distance = 0
  path = []
  priorityQueue.put((heuristics[startNode] + distance, [startNode, 0]))
  while priorityQueue.empty() == False:
    current = priorityQueue.get()[1]
    path.append(current[0])
    distance += int(current[1])
    if current[0] == goalNode:
      break
    priorityQueue = queue.PriorityQueue()
    for i in graph[current[0]]:
      if i[0] not in path:
        priorityQueue.put((heuristics[i[0]] + int(i[1]) + distance, i))
  return path

heuristic = getHeuristics()
graph = createGraph()

cityName = "Zerind"
gbfs = GBFS(cityName, heuristic, graph)
astar = Astar(cityName, heuristic, graph)
print("GBFS => ", gbfs)
print("ASTAR => ", astar)

#For a given path, find out the cost
def getStepCost(source, target):
  file = open("citiesGraph.txt")
  for i in file.readlines():
    parts = i.split(" ")
    if parts[0] == source and parts[1] == target:
      #file.close()
      return int(parts[2])
    if parts[0] == target and parts[1] == source:
      #file.close()
      return int(parts[2])
  return 0

def getPathCost(route):
  pathCost = 0
  for i in range(0, len(route) - 1):
    source = route[i]
    target = route[i+1]
    pathCost += getStepCost(source, target)
  return pathCost

print(getPathCost(gbfs))

#Get the Heuristics from a File
#We'll try to calculate the heuristics as the (a) Manhattan distance, and (b) Euclidean distance
def getManhattanHeuristic(goal):
  file = open("cities.txt", "r")
  lines = file.readlines()
  goalX = 0
  goalY = 0
  cityList = set()
  for line in lines:
    parts = line.split(" ")
    cityList.add(parts[0])
  for line in lines:
    parts = line.split(" ")
    if parts[0] == goal:
      goalX = int(parts[1])
      goalY = int(parts[2])
      break
  heuristics = {}
  for line in lines:
    parts = line.split(" ")
    cityX = int(parts[1])
    cityY = int(parts[2])
    xDiff = abs(cityX - goalX)
    yDiff = abs(cityY - goalY)
    heuristics[parts[0]] = xDiff + yDiff
  #print(heuristics)
  return heuristics

import math
def getEuclideanHeuristic(goal):
  file = open("cities.txt", "r")
  lines = file.readlines()
  goalX = 0
  goalY = 0
  cityList = set()
  for line in lines:
    parts = line.split(" ")
    cityList.add(parts[0])
  for line in lines:
    parts = line.split(" ")
    if parts[0] == goal:
      goalX = int(parts[1])
      goalY = int(parts[2])
      break
  heuristics = {}
  for line in lines:
    parts = line.split(" ")
    cityX = int(parts[1])
    cityY = int(parts[2])
    xDiff = abs(cityX - goalX)
    yDiff = abs(cityY - goalY)
    heuristics[parts[0]] = math.sqrt(xDiff*xDiff + yDiff*yDiff)
  #print(heuristics)
  return heuristics

print(getManhattanHeuristic("Neamt"))

goalNode = "Neamt"
heuristic = getManhattanHeuristic(goalNode)
graph = createGraph()

cityName = "Oradea"
gbfs = GBFS(cityName, heuristic, graph, goalNode)
astar = Astar(cityName, heuristic, graph, goalNode)
print("GBFS => ", gbfs)
print("ASTAR => ", astar)

print(getPathCost(gbfs))
print(getPathCost(astar))

print(getEuclideanHeuristic("Neamt"))

goalNode = "Neamt"
heuristic = getEuclideanHeuristic(goalNode)
graph = createGraph()

cityName = "Oradea"
gbfs = GBFS(cityName, heuristic, graph, goalNode)
astar = Astar(cityName, heuristic, graph, goalNode)
print("GBFS => ", gbfs)
print("ASTAR => ", astar)

print(getPathCost(gbfs))
print(getPathCost(astar))